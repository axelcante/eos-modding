using System.Collections.Generic;
using System.IO;
using System.Text;
using System;
using UnityEngine;

namespace RomeroGames
{
    /// <summary>
    /// Utilities for working with Windows and MacOS file systems.
    /// </summary>
    public static class EoSPathUtils
    {
        private static string GetProperDirectoryCapitalization(DirectoryInfo dirInfo)
        {
            DirectoryInfo parentDirInfo = dirInfo.Parent;
            if (null == parentDirInfo)
                return dirInfo.Name;
            return Path.Combine(GetProperDirectoryCapitalization(parentDirInfo),
                                parentDirInfo.GetDirectories(dirInfo.Name)[0].Name);
        }

        private static string GetProperFilePathCapitalization(string filename)
        {
            FileInfo fileInfo = new FileInfo(filename);
            DirectoryInfo dirInfo = fileInfo.Directory;
            return Path.Combine(GetProperDirectoryCapitalization(dirInfo),
                                dirInfo.GetFiles(fileInfo.Name)[0].Name);
        }

        private static StringBuilder _stringBuilder = new StringBuilder();

        #region Public members

        /// <summary>
        /// The path to the Mods folder.
        /// </summary>
        public const string ModsPath = "Assets/Mods/";
        public const string AutoGeneratedFolderName = "_AutoGenerated";

        public static string GetAutoGeneratedFolder(string modName)
        {
            return CombinePath(ModsPath, modName, AutoGeneratedFolderName);
        }

        /// <summary>
        /// Returns true if the file has a scene file extension.
        /// </summary>
        public static bool IsSceneFile(string file)
        {
            if (string.IsNullOrEmpty(file))
            {
                return false;
            }
            return file.EndsWith(".unity");
        }

        /// <summary>
        /// Converts a path string to use only single forward slashes as path separator.
        /// </summary>
        public static string CleanPath(string path)
        {
            return path.Replace("\\", "/");
        }

        /// <summary>
        /// Joins multiple path strings using a path separator, and then cleans the combined path.
        /// </summary>
        public static string CombinePath(string basePath, params string[] addPathList)
        {
            if (_stringBuilder == null)
            {
                // This method may be called extremely early during Editor startup, before
                // we get a chance to initialize statics, so ensure it's always initialized.
                _stringBuilder = new StringBuilder();
            }
            else
            {
                _stringBuilder.Clear();
            }

            _stringBuilder.Append(basePath);
            foreach(string s in addPathList)
            {
                _stringBuilder.Append('/');
                _stringBuilder.Append(s);
            }

            _stringBuilder.Replace("\\", "/");
            _stringBuilder.Replace("//", "/");

            return _stringBuilder.ToString();
        }

        /// <summary>
        /// Returns an Asset Key given an asset path in a mod folder.
        /// </summary>
        public static string GetAssetKeyFromPath(string assetPath)
        {
            if (string.IsNullOrEmpty(assetPath))
            {
                Debug.LogError("Asset path is empty");
                return string.Empty;
            }

            string cleanPath = Path.ChangeExtension(CleanPath(assetPath), null);

            if (!assetPath.StartsWith(ModsPath))
            {
                Debug.LogErrorFormat("Asset path does not start with 'Assets/Mods/': {0}", assetPath);
                return string.Empty;
            }

            if (assetPath.Length < ModsPath.Length + 1)
            {
                Debug.LogErrorFormat("Asset path does not contain an asset key: {0}", assetPath);
                return string.Empty;
            }

            // Find index of 3rd path seperator
            int keyIndex = cleanPath.IndexOf('/', ModsPath.Length);
            if (keyIndex == -1)
            {
                Debug.LogErrorFormat("Asset path does not contain a mod folder seperator: {0}", assetPath);
                return string.Empty;
            }

            return cleanPath.Substring(keyIndex + 1);
        }

        /// <summary>
        /// Returns the mod part of an asset path.
        /// </summary>
        public static string GetModPathFromAssetPath(string assetPath)
        {
            if (string.IsNullOrEmpty(assetPath))
            {
                Debug.LogError("Asset path is empty");
                return string.Empty;
            }

            string cleanPath = CleanPath(assetPath);

            if (!assetPath.StartsWith(ModsPath))
            {
                Debug.LogErrorFormat("Asset path does not start with 'Assets/Mods/': {0}", assetPath);
                return string.Empty;
            }

            if (assetPath.Length < ModsPath.Length + 1)
            {
                Debug.LogErrorFormat("Asset path does not contain an asset key: {0}", assetPath);
                return string.Empty;
            }

            // Find the index of the third dir seperator
            int i = 0;
            int seperatorCount = 0;
            while (i < cleanPath.Length && seperatorCount < 3)
            {
                if (cleanPath[i] == '/')
                {
                    seperatorCount++;
                }
                i++;
            }

            if (seperatorCount != 3 ||
                i >= cleanPath.Length)
            {
                Debug.LogErrorFormat("Failed to create mod path for asset path: {1}", seperatorCount);
                return string.Empty;
            }

            return cleanPath.Substring(0, i);
        }

        /// <summary>
        /// Returns the asset-relative path of the directory containing the given asset
        /// eg. GetAssetDirectoryFromPath("Assets/Mods/GameData/Xml/MainMenu.xml") => "Assets/Mods/GameData/Xml"
        /// </summary>
        public static string GetAssetParentDirectory(string assetPath)
        {
            if (string.IsNullOrEmpty(assetPath))
            {
                Debug.LogErrorFormat("Asset path is null or empty");
                return string.Empty;
            }

            if (assetPath.Length < ModsPath.Length + 1)
            {
                Debug.LogErrorFormat("Asset path does not contain an asset key: {0}", assetPath);
                return string.Empty;
            }

            string path = CleanPath(assetPath);

            int separatorIndex = path.LastIndexOf('/');

            // Remove any trailing separator
            if (separatorIndex == (path.Length - 1))
            {
                path = path.Substring(0, path.Length - 1);
                separatorIndex = path.LastIndexOf('/');
            }

            return path.Substring(0, separatorIndex);
        }

        /// <summary>
        /// Returns the absolute physical path for a given path.
        /// This is useful for case-sensitive path checks and assumes.
        /// Path seperators are converted to '/' on all platforms.
        /// If the path does not exist on disk then the empty string is returned.
        /// </summary>
        public static string GetPhysicalPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return string.Empty;
            }

            string physicalPath = GetProperFilePathCapitalization(path);
            if (string.IsNullOrEmpty(physicalPath))
            {
                return string.Empty;
            }

            return CleanPath(physicalPath);
        }

        // This method is used instead of AssetDatabase.GetSubFolders() which is broken in Unity 2017.1
        public static string[] GetSubFolders(string path)
        {
            List<string> subFolders = new List<string>();

            DirectoryInfo directory = new DirectoryInfo(path);
            DirectoryInfo[] directories = directory.GetDirectories();

            foreach (DirectoryInfo folder in directories)
            {
                string p = CombinePath (path, folder.Name);
                subFolders.Add(p);
            }

            return subFolders.ToArray();
        }

        public static List<string> GetSubFolderNames(string path)
        {
            List<string> subFolders = new List<string>();
            DirectoryInfo directory = new DirectoryInfo(path);
            DirectoryInfo[] directories = directory.GetDirectories();
            foreach (DirectoryInfo folder in directories)
            {
                subFolders.Add(folder.Name);
            }
            return subFolders;
        }

        // Returns a list of all subfolders recursively through the tree.
        public static string[] GetAllSubFolders(string path)
        {
            List<string> subFolders = new List<string>();

            DirectoryInfo directory = new DirectoryInfo(path);
            DirectoryInfo[] directories = directory.GetDirectories("*.*", SearchOption.AllDirectories);

            foreach (DirectoryInfo folder in directories)
            {
                string p = CleanPath(folder.FullName);
                subFolders.Add(p);
            }

            return subFolders.ToArray();
        }

        public static bool GetDirectoryExists(string path)
        {
            return new DirectoryInfo(path).Exists;
        }

        // Converts from "SOME_ID" to "Some Id" (if space used as separator)
        public static string ConvertCase(string input, string separator)
        {
            if (string.IsNullOrEmpty(input))
            {
                return string.Empty;
            }

            string output = string.Empty;
            string[] nameParts = input.Split( new char[] { '_' } );
            foreach (string namePart in nameParts)
            {
                if (namePart.Length <= 1)
                {
                    output += namePart.ToUpperInvariant();
                }
                else
                {
                    char firstChar = Char.ToUpperInvariant(namePart[0]);
                    string lowercase = namePart.ToLowerInvariant();
                    lowercase = firstChar + lowercase.Substring(1, lowercase.Length - 1);
                    output += lowercase;
                }
                if (!string.IsNullOrEmpty(separator))
                {
                    output += separator;
                }
            }

            return output.Trim();
        }

        #endregion
    }
}